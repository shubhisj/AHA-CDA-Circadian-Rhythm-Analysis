---
title: "AHA-CDA"
author: "Shubhi Jain"
date: "2025-08-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```


# Installing necessary packages
```{r}
install.packages("dplyr")
install.packages("ggplot2")
install.packages("tidyr")
install.packages("writexl")
install.packages("purrr")
install.packages("broom")
install.packages("nlme")
install.packages("rmarkdown")
install.packages("tinytex")
install.packages("performance")
```

```{r}
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(broom)
library(purrr)
library(writexl)
library(nlme)
library(tinytex)
library(rmarkdown)
library(performance)
```

### Individual ID analysis

# Importing SCN-BP dataset
```{r}
aha_data <- read_excel("~/Desktop/UAB/AHA CDA/AHA-Updated/AHA-CDA Code/AHA Dataset-Final.xlsx", sheet = 1)
dim(aha_data)
#View(aha_data)
```

#Cleaning SCN-BP data
```{r}
aha_data2 <- aha_data %>% 
  # IDs excluded due to inadequate data
  filter(!(ID %in% c("100", "105", "107", "111", "112", "118", "119", "127", "132", "134", "136", "152", "154")) &
    Time.In.Trial.Hrs > 6) %>% 
  mutate(SBP = as.numeric(SBP), DBP = as.numeric(DBP), CBT.C = as.numeric(CBT.C), MAP = as.numeric(MAP), HR = as.numeric(HR), PP = as.numeric(PP), Melatonin = as.numeric(Melatonin))
dim(aha_data2)
#View(aha_data2)
```

#Determining cosine and sine components
```{r}
aha_data2$COS.CT.24 <- cos(2 * pi * aha_data2$Time.In.Trial.Hrs / 24.1)
aha_data2$SIN.CT.24 <- sin(2 * pi * aha_data2$Time.In.Trial.Hrs / 24.1)
aha_data2$COS.CT.12 <- cos(2 * pi * aha_data2$Time.In.Trial.Hrs / 12.05)
aha_data2$SIN.CT.12 <- sin(2 * pi * aha_data2$Time.In.Trial.Hrs / 12.05)
```

## Using linearized model to manually calculate M, AMP and Phase for each ID

# Note: Please refer to dataset sheet = 2 (CBT Min Calculation) to see results
```{r}
estimates_lm <- aha_data2 %>% 
  group_by(ID) %>%
  nest() %>%
  mutate(model = map(data, ~lm(CBT.C ~ COS.CT.24 + SIN.CT.24 + COS.CT.12 + SIN.CT.12, data = .x)),

#Extracting the full model summary for each ID (r-squared and p-values)
    tidied = map(model, tidy),
    glanced = map(model, glance))

#Printing model summary
results_glanced <- estimates_lm %>%
  dplyr::select(ID, glanced) %>%
  unnest(cols = c(glanced))
print(results_glanced)

# Calculating mesor, amplitude and phase by extraction coefficients from linear model
estimates_lm <- estimates_lm %>% 
  mutate(
    beta_cos24 = map_dbl(model, ~ coef(.x)['COS.CT.24']),
    beta_sin24 = map_dbl(model, ~ coef(.x)['SIN.CT.24']),
    beta_cos12 = map_dbl(model, ~ coef(.x)['COS.CT.12']),
    beta_sin12 = map_dbl(model, ~ coef(.x)['SIN.CT.12']),
    amplitude_24 = sqrt(beta_cos24^2 + beta_sin24^2),
    phase_24 = atan2(-beta_sin24, beta_cos24),
    amplitude_12 = sqrt(beta_cos12^2 + beta_sin12^2),
    phase_12 = atan2(-beta_sin12, beta_cos12)
  )

results <- estimates_lm %>% 
  mutate(mesor=map_dbl(model, ~ coef(.x)['(Intercept)'])) %>%
  dplyr::select(ID, mesor, amplitude_24, phase_24, amplitude_12, phase_12)

print(results)
```

# Please refer to dataset sheet = 3 to see CBT phase

# Importing CBT.min dataset to get the Relative.Clock.Time

```{r}
clock_data_aha <- read_excel("~/Desktop/UAB/AHA CDA/AHA-Updated/AHA-CDA Code/AHA Dataset-Final.xlsx", sheet = 3)
#View(clock_data_aha)
```

# Cleaning CBT.min dataset
```{r}
clock_data_aha2 <- clock_data_aha %>% 
  filter(!(ID %in% c("100", "105", "107", "111", "112", "118", "119", "127", "132", "134", "136","152", "154")) &
    Time.In.Trial.Hrs > 6) %>% 
  mutate(CBT.Phase = round(CBT.Phase, 2))
#View(clock_data_aha2)
```

# Merging both datasets
```{r}
merged_aha <- aha_data2 %>%
  left_join(clock_data_aha2 %>% 
              dplyr::select(ID, Time.In.Trial.Hrs, CBT.Phase), by = c("ID", "Time.In.Trial.Hrs")) %>% 
    filter(!(ID %in% c("100", "105", "107", "111", "112", "118", "119", "127", "132", "134", "136", "152", "154")))
View(merged_aha)
```

### Mixed Effect Model Analysis on the merged dataset (all variables vs CBT Phase)

# Determining cosinor and harmonic components for Relative Clock Time
```{r}
merged_aha2 <- merged_aha %>% 
  mutate(
    #Cosinor Component 24
    COS.CBT.CT.24 = cos(2 * pi * CBT.Phase / 24),
    SIN.CBT.CT.24 = sin(2 * pi * CBT.Phase / 24),
    #Harmonic Component 12
    COS.CBT.CT.12 = cos(2 * pi * CBT.Phase / 12),
    SIN.CBT.CT.12 = sin(2 * pi * CBT.Phase / 12)
  )
```

# Creating a Time Index that represents the sequential order of repeated measurements within each subject
```{r}
# To ensure that within each subject, you have a unique, sequential time index, we create a variable called TimeIndex
merged_aha3 <- merged_aha2 %>%
  group_by(ID) %>%
  arrange(CBT.Phase) %>%
  mutate(Time.Index = row_number()) %>%
  ungroup()
#View(merged_aha3)
```

## SBP vs CBT phase

```{r}
# Splitting the data by Dipping.Status
models_sbp <- merged_aha3 %>%
  group_by(DippingStatus) %>%
  nest() %>%
  #Fitting model for each group
  mutate(
    model = map(data, ~ lme(
      fixed = SBP ~ CBT.Phase + COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12,
      random = ~ 1 | ID,                      
      correlation = corARMA(p = 1, q = 1, form = ~ Time.Index | ID),
      data = .x,
      method = "REML",
      na.action = na.exclude
    )),
  
    model_summary = map(model, summary),
    anova_table   = map(model, anova)
  )

# Printing model summaries
models_sbp %>%
  dplyr::select(DippingStatus, model_summary) %>%
  pwalk(function(DippingStatus, model_summary) {
    cat("\n===== DippingStatus:", DippingStatus, "=====\n")
    print(model_summary)
  })

# Printing ANOVA tables
models_sbp %>%
  dplyr::select(DippingStatus, anova_table) %>%
  pwalk(function(DippingStatus, anova_table) {
    cat("\n===== ANOVA for DippingStatus:", DippingStatus, "=====\n")
    print(anova_table)
  })


#Checking regression diagnostics
check_model(models_sbp$model[[1]])
```

# Extracting fixed coefficients from AR1 model
```{r}
models_sbp <- models_sbp %>%
  mutate(
    fixed_coefs = map(model, fixef), 
    
    #Computing mesor, amplitude and phase for each group
    mesor   = map_dbl(fixed_coefs, ~ .x["(Intercept)"]),
    amp_24  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.24"]^2 + .x["SIN.CBT.CT.24"]^2)),
    phase_24 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.24"], .x["COS.CBT.CT.24"])),
    amp_12  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.12"]^2 + .x["SIN.CBT.CT.12"]^2)),
    phase_12 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.12"], .x["COS.CBT.CT.12"])),
    B1       = map_dbl(fixed_coefs, ~ .x["CBT.Phase"]),
  )

models_sbp %>%
  select(DippingStatus, mesor, amp_24, phase_24, amp_12, phase_12, B1)
```

## CBT vs CBT phase

```{r}
# Splitting the data by Dipping.Status
models_cbt <- merged_aha3 %>%
  group_by(DippingStatus) %>%
  nest() %>%
  #Fitting model for each group
  mutate(
    model = map(data, ~ lme(
      fixed = CBT.C ~ COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12,
      random = ~ 1 | ID,                      
      #correlation = corAR1(form = ~ Time.Index | ID), 
      correlation = corARMA(p = 1, q = 1, form = ~ Time.Index | ID),
      data = .x,
      method = "REML",
      na.action = na.exclude
    )),
  
    model_summary = map(model, summary),
    anova_table   = map(model, anova)
  )

# Printing model summaries
models_cbt %>%
  dplyr::select(DippingStatus, model_summary) %>%
  pwalk(function(DippingStatus, model_summary) {
    cat("\n===== DippingStatus:", DippingStatus, "=====\n")
    print(model_summary)
  })

# Printing ANOVA tables
models_cbt %>%
  dplyr::select(DippingStatus, anova_table) %>%
  pwalk(function(DippingStatus, anova_table) {
    cat("\n===== ANOVA for DippingStatus:", DippingStatus, "=====\n")
    print(anova_table)
  })


#Checking regression diagnostics
check_model(models_cbt$model[[1]])

#ACF plot
mod <- models_cbt$model[[1]]
res <- resid(mod, type = "normalized")
res_clean <- na.omit(res)

acf(res_clean, lag.max = 20,
    main = "ACF of normalized residuals")
```

# Extracting fixed coefficients from AR1 model
```{r}
models_cbt <- models_cbt %>%
  mutate(
    fixed_coefs = map(model, fixef), 
    
    #Computing mesor, amplitude and phase for each group
    mesor   = map_dbl(fixed_coefs, ~ .x["(Intercept)"]),
    amp_24  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.24"]^2 + .x["SIN.CBT.CT.24"]^2)),
    phase_24 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.24"], .x["COS.CBT.CT.24"])),
    amp_12  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.12"]^2 + .x["SIN.CBT.CT.12"]^2)),
    phase_12 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.12"], .x["COS.CBT.CT.12"]))
  )

models_cbt %>%
  select(DippingStatus, mesor, amp_24, phase_24, amp_12, phase_12)
```

## HR vs CBT phase

```{r}
# Splitting the data by Dipping.Status
models_hr <- merged_aha3 %>%
  group_by(DippingStatus) %>%
  nest() %>%
  #Fitting model for each group
  mutate(
    model = map(data, ~ lme(
      fixed = HR ~ COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12 + CBT.Phase,
      random = ~ 1 | ID,                      
      correlation = corARMA(p = 1, q = 1, form = ~ Time.Index | ID),
      data = .x,
      method = "REML",
      na.action = na.exclude
    )),
  
    model_summary = map(model, summary),
    anova_table   = map(model, anova)
  )

# Printing model summaries
models_hr %>%
  select(DippingStatus, model_summary) %>%
  pwalk(function(DippingStatus, model_summary) {
    cat("\n===== DippingStatus:", DippingStatus, "=====\n")
    print(model_summary)
  })

# Printing ANOVA tables
models_hr %>%
  select(DippingStatus, anova_table) %>%
  pwalk(function(DippingStatus, anova_table) {
    cat("\n===== ANOVA for DippingStatus:", DippingStatus, "=====\n")
    print(anova_table)
  })


#Checking regression diagnostics
check_model(models_hr$model[[1]])

#ACF plot
mod <- models_hr$model[[1]]
res <- resid(mod, type = "normalized")
res_clean <- na.omit(res)

acf(res_clean, lag.max = 20,
    main = "ACF of normalized residuals")

```

# Extracting fixed coefficients from AR1 model
```{r}
models_hr <- models_hr %>%
  mutate(
    fixed_coefs = map(model, fixef), 
    
    #Computing mesor, amplitude and phase for each group
    mesor   = map_dbl(fixed_coefs, ~ .x["(Intercept)"]),
    amp_24  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.24"]^2 + .x["SIN.CBT.CT.24"]^2)),
    phase_24 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.24"], .x["COS.CBT.CT.24"])),
    amp_12  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.12"]^2 + .x["SIN.CBT.CT.12"]^2)),
    phase_12 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.12"], .x["COS.CBT.CT.12"])),
    B1       = map_dbl(fixed_coefs, ~ .x["CBT.Phase"]),
  )

models_hr %>%
  select(DippingStatus, mesor, amp_24, phase_24, amp_12, phase_12, B1)
```

## DBP vs CBT phase

```{r}
# Splitting the data by Dipping.Status
models_dbp <- merged_aha3 %>%
  group_by(DippingStatus) %>%
  nest() %>%
  #Fitting model for each group
  mutate(
    model = map(data, ~ lme(
      fixed = DBP ~ COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12 + CBT.Phase,
      random = ~ 1 | ID,                      
      correlation = corARMA(p = 1, q = 1, form = ~ Time.Index | ID),
      data = .x,
      method = "REML",
      na.action = na.exclude
    )),
  
    model_summary = map(model, summary),
    anova_table   = map(model, anova)
  )

# Printing model summaries
models_dbp %>%
  select(DippingStatus, model_summary) %>%
  pwalk(function(DippingStatus, model_summary) {
    cat("\n===== DippingStatus:", DippingStatus, "=====\n")
    print(model_summary)
  })

# Printing ANOVA tables
models_dbp %>%
  select(DippingStatus, anova_table) %>%
  pwalk(function(DippingStatus, anova_table) {
    cat("\n===== ANOVA for DippingStatus:", DippingStatus, "=====\n")
    print(anova_table)
  })

#Checking regression diagnostics
check_model(models_dbp$model[[1]])

#ACF plot
mod <- models_dbp$model[[1]]
res <- resid(mod, type = "normalized")
res_clean <- na.omit(res)

acf(res_clean, lag.max = 20,
    main = "ACF of normalized residuals")

```

# Extracting fixed coefficients from AR1 model
```{r}
models_dbp <- models_dbp %>%
  mutate(
    fixed_coefs = map(model, fixef), 
    
    #Computing mesor, amplitude and phase for each group
    mesor   = map_dbl(fixed_coefs, ~ .x["(Intercept)"]),
    amp_24  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.24"]^2 + .x["SIN.CBT.CT.24"]^2)),
    phase_24 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.24"], .x["COS.CBT.CT.24"])),
    amp_12  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.12"]^2 + .x["SIN.CBT.CT.12"]^2)),
    phase_12 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.12"], .x["COS.CBT.CT.12"])),
    B1       = map_dbl(fixed_coefs, ~ .x["CBT.Phase"]),
  )

models_dbp %>%
  select(DippingStatus, mesor, amp_24, phase_24, amp_12, phase_12, B1)
```

## PP vs CBT phase

```{r}
# Splitting the data by Dipping.Status
models_pp <- merged_aha3 %>%
  group_by(DippingStatus) %>%
  nest() %>%
  #Fitting model for each group
  mutate(
    model = map(data, ~ lme(
      fixed = PP ~ COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12 + CBT.Phase,
      random = ~ 1 | ID,                      
      correlation = corARMA(p = 1, q = 1, form = ~ Time.Index | ID),
      data = .x,
      method = "REML",
      na.action = na.exclude
    )),
  
    model_summary = map(model, summary),
    anova_table   = map(model, anova)
  )

# Printing model summaries
models_pp %>%
  select(DippingStatus, model_summary) %>%
  pwalk(function(DippingStatus, model_summary) {
    cat("\n===== DippingStatus:", DippingStatus, "=====\n")
    print(model_summary)
  })

# Printing ANOVA tables
models_pp %>%
  select(DippingStatus, anova_table) %>%
  pwalk(function(DippingStatus, anova_table) {
    cat("\n===== ANOVA for DippingStatus:", DippingStatus, "=====\n")
    print(anova_table)
  })


#Checking regression diagnostics
check_model(models_pp$model[[1]])

#ACF plot
mod <- models_pp$model[[1]]
res <- resid(mod, type = "normalized")
res_clean <- na.omit(res)

acf(res_clean, lag.max = 20,
    main = "ACF of normalized residuals")

```

# Extracting fixed coefficients from AR1 model
```{r}
models_pp <- models_pp %>%
  mutate(
    fixed_coefs = map(model, fixef), 
    
    #Computing mesor, amplitude and phase for each group
    mesor   = map_dbl(fixed_coefs, ~ .x["(Intercept)"]),
    amp_24  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.24"]^2 + .x["SIN.CBT.CT.24"]^2)),
    phase_24 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.24"], .x["COS.CBT.CT.24"])),
    amp_12  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.12"]^2 + .x["SIN.CBT.CT.12"]^2)),
    phase_12 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.12"], .x["COS.CBT.CT.12"])),
    B1       = map_dbl(fixed_coefs, ~ .x["CBT.Phase"]),
  )

models_pp %>%
  select(DippingStatus, mesor, amp_24, phase_24, amp_12, phase_12, B1)
```

## MAP vs CBT phase

```{r}
# Splitting the data by Dipping.Status
models_map <- merged_aha3 %>%
  group_by(DippingStatus) %>%
  nest() %>%
  #Fitting model for each group
  mutate(
    model = map(data, ~ lme(
      fixed = MAP ~ COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12 + CBT.Phase,
      random = ~ 1 | ID,                      
      correlation = corARMA(p = 1, q = 1, form = ~ Time.Index | ID),
      data = .x,
      method = "REML",
      na.action = na.exclude
    )),
  
    model_summary = map(model, summary),
    anova_table   = map(model, anova)
  )

# Printing model summaries
models_map %>%
  select(DippingStatus, model_summary) %>%
  pwalk(function(DippingStatus, model_summary) {
    cat("\n===== DippingStatus:", DippingStatus, "=====\n")
    print(model_summary)
  })

# Printing ANOVA tables
models_map %>%
  select(DippingStatus, anova_table) %>%
  pwalk(function(DippingStatus, anova_table) {
    cat("\n===== ANOVA for DippingStatus:", DippingStatus, "=====\n")
    print(anova_table)
  })

#Checking regression diagnostics
check_model(models_map$model[[1]])

#ACF plot
mod <- models_map$model[[1]]
res <- resid(mod, type = "normalized")
res_clean <- na.omit(res)

acf(res_clean, lag.max = 20,
    main = "ACF of normalized residuals")

```

# Extracting fixed coefficients from AR1 model
```{r}
models_map <- models_map %>%
  mutate(
    fixed_coefs = map(model, fixef), 
    
    #Computing mesor, amplitude and phase for each group
    mesor   = map_dbl(fixed_coefs, ~ .x["(Intercept)"]),
    amp_24  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.24"]^2 + .x["SIN.CBT.CT.24"]^2)),
    phase_24 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.24"], .x["COS.CBT.CT.24"])),
    amp_12  = map_dbl(fixed_coefs, ~ sqrt(.x["COS.CBT.CT.12"]^2 + .x["SIN.CBT.CT.12"]^2)),
    phase_12 = map_dbl(fixed_coefs, ~ atan2(-.x["SIN.CBT.CT.12"], .x["COS.CBT.CT.12"])),
    B1       = map_dbl(fixed_coefs, ~ .x["CBT.Phase"]),
  )

models_map %>%
  select(DippingStatus, mesor, amp_24, phase_24, amp_12, phase_12, B1)
```

# Binning Relative.Clock.Time into 24 segments to create plots on Graphpad
```{r}
# define cuts at every integer hour
hourly_breaks <- seq(0, 24, by = 1)


# Creating the binned time variable 
merged_aha4 <- merged_aha %>%
  mutate(CBT.Phase.binned = cut(CBT.Phase,
                                          breaks =  hourly_breaks,
                                          labels = paste0(0:23, "-", 1:24), 
                                          include.lowest = TRUE,
                                          right = FALSE))

# Calculating means and SEM for each variable
summary_binned_final <- merged_aha4 %>%
  filter(!is.na(CBT.Phase.binned)) %>%
  group_by(DippingStatus, CBT.Phase.binned) %>%
  summarize(
    mean_SBP = mean(SBP, na.rm = TRUE),
    se_SBP   = sd(SBP, na.rm = TRUE) / sqrt(n()),
    mean_DBP = mean(DBP, na.rm = TRUE),
    se_DBP   = sd(DBP, na.rm = TRUE) / sqrt(n()),
    mean_CBT = mean(CBT.C, na.rm = TRUE),
    se_CBT   = sd(CBT.C, na.rm = TRUE) / sqrt(n()),
    mean_HR  = mean(HR, na.rm = TRUE),
    se_HR    = sd(HR, na.rm = TRUE) / sqrt(n()),
    mean_PP  = mean(PP, na.rm = TRUE),
    se_PP    = sd(PP, na.rm = TRUE) / sqrt(n()),
    mean_MAP  = mean(MAP, na.rm = TRUE),
    se_MAP    = sd(MAP, na.rm = TRUE) / sqrt(n()),
    n        = n(),
    .groups = "drop"
  )

print(summary_binned_final)
#View(merged_aha4)
table(merged_aha4$CBT.Phase.binned, merged_aha4$DippingStatus)
```

# Exporting the data to excel file
# Exported excel file is used to create figures on Graphphad Prism
```{r}
write_xlsx(summary_binned_final, "aha_final.xlsx")
```

#------------------------------------------------------------------------------------

# Testing the significance of rhythms for each ID

# SBP vs CBT Phase
```{r}
estimates_sbp <- merged_aha2 %>% 
  group_by(ID) %>%
  nest() %>%
  mutate(model = map(data, ~lm(SBP ~ COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12 + CBT.Phase, data = .x)),

#Extracting the full model summary for each ID (r-squared and p-values)
    tidied = map(model, tidy),
    glanced = map(model, glance))

#Printing model summary
results_glanced <- estimates_sbp %>%
  select(ID, glanced) %>%
  unnest(cols = c(glanced))
print(results_glanced)

# Calculating mesor, amplitude and phase by extraction coefficients from linear model
estimates_sbp <- estimates_sbp %>% 
  mutate(
    beta_cos24 = map_dbl(model, ~ coef(.x)['COS.CBT.CT.24']),
    beta_sin24 = map_dbl(model, ~ coef(.x)['SIN.CBT.CT.24']),
    beta_cos12 = map_dbl(model, ~ coef(.x)['COS.CBT.CT.12']),
    beta_sin12 = map_dbl(model, ~ coef(.x)['SIN.CBT.CT.12']),
    B1         = map_dbl(model, ~ coef(.x)['CBT.Phase']),
    amplitude_24 = sqrt(beta_cos24^2 + beta_sin24^2),
    phase_24 = atan2(-beta_sin24, beta_cos24),
    amplitude_12 = sqrt(beta_cos12^2 + beta_sin12^2),
    phase_12 = atan2(-beta_sin12, beta_cos12),
  )

results <- estimates_sbp %>% 
  mutate(mesor=map_dbl(model, ~ coef(.x)['(Intercept)'])) %>%
  select(ID, mesor, amplitude_24, phase_24, amplitude_12, phase_12, B1)

print(results)
```

# DBP vs CBT Phase
```{r}
estimates_dbp <- merged_aha2 %>% 
  group_by(ID) %>%
  nest() %>%
  mutate(model = map(data, ~lm(DBP ~ COS.CBT.CT.24 + SIN.CBT.CT.24 + COS.CBT.CT.12 + SIN.CBT.CT.12 + CBT.Phase, data = .x)),

#Extracting the full model summary for each ID (r-squared and p-values)
    tidied = map(model, tidy),
    glanced = map(model, glance))

#Printing model summary
results_glanced <- estimates_dbp %>%
  select(ID, glanced) %>%
  unnest(cols = c(glanced))
print(results_glanced)

# Calculating mesor, amplitude and phase by extraction coefficients from linear model
estimates_dbp <- estimates_dbp %>% 
  mutate(
    beta_cos24 = map_dbl(model, ~ coef(.x)['COS.CBT.CT.24']),
    beta_sin24 = map_dbl(model, ~ coef(.x)['SIN.CBT.CT.24']),
    beta_cos12 = map_dbl(model, ~ coef(.x)['COS.CBT.CT.12']),
    beta_sin12 = map_dbl(model, ~ coef(.x)['SIN.CBT.CT.12']),
    B1         = map_dbl(model, ~ coef(.x)['CBT.Phase']),
    amplitude_24 = sqrt(beta_cos24^2 + beta_sin24^2),
    phase_24 = atan2(-beta_sin24, beta_cos24),
    amplitude_12 = sqrt(beta_cos12^2 + beta_sin12^2),
    phase_12 = atan2(-beta_sin12, beta_cos12),
  )

results <- estimates_dbp %>% 
  mutate(mesor=map_dbl(model, ~ coef(.x)['(Intercept)'])) %>%
  select(ID, mesor, amplitude_24, phase_24, amplitude_12, phase_12, B1)

print(results)
```






